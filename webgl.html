<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL from C</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
            background: #1a1a2e;
            color: #eee;
            line-height: 1.6;
        }
        h1 { color: #00d4ff; border-bottom: 2px solid #00d4ff; padding-bottom: 0.5rem; }
        h2 { color: #ff6b6b; margin-top: 2rem; }
        .section {
            background: #16213e;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }
        canvas {
            border: 2px solid #00d4ff;
            border-radius: 4px;
            display: block;
            margin: 1rem 0;
        }
        button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin: 0.25rem;
        }
        button:hover { opacity: 0.9; }
        button.active { background: #00ff88; }
        .stats {
            font-family: monospace;
            color: #00ff88;
            margin-top: 0.5rem;
        }
        #status { padding: 1rem; border-radius: 4px; margin-bottom: 1rem; }
        .loading { background: #ff9f1c33; color: #ff9f1c; }
        .ready { background: #00ff8833; color: #00ff88; }
        .concept {
            background: #0f3460;
            border-left: 4px solid #00d4ff;
            padding: 1rem;
            margin: 1rem 0;
        }
        code { background: #0f0f23; padding: 0.2rem 0.4rem; border-radius: 3px; }
        pre { background: #0f0f23; padding: 1rem; border-radius: 4px; overflow-x: auto; margin: 1rem 0; }
        .controls { margin: 1rem 0; }
        .grid-container {
            position: relative;
            display: inline-block;
        }
        .text-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .cell-text {
            position: absolute;
            color: #fff;
            font-size: 12px;
            font-family: monospace;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
        }
        .cell-text:hover {
            color: #00ff88;
        }
        .cell-text.editing {
            background: #00d4ff;
            color: #000;
            outline: none;
            pointer-events: auto;
        }
        .cell-text.locked {
            color: #ffff00 !important;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>WebGL Rendering from C</h1>
    
    <div id="status" class="loading">Loading WebAssembly module...</div>

    <div class="concept">
        <h3>ðŸš€ The GPU Pipeline</h3>
        <pre>
Vertices (C)  â†’  Vertex Shader  â†’  Rasterizer  â†’  Fragment Shader  â†’  Pixels
    â†“                â†“                 â†“                â†“
[x,y,r,g,b]    Position each     Convert to      Color each
               vertex            pixels          pixel</pre>
        <p>Everything runs on the GPU in parallel â€” millions of operations simultaneously!</p>
    </div>

    <h2>Demo 1: Basic WebGL Quad</h2>
    <div class="section">
        <canvas id="webgl-canvas" width="600" height="300"></canvas>
        <div class="controls">
            <button id="btnAnimate" onclick="toggleAnimation()">Start Animation</button>
        </div>
        <div class="stats" id="stats1">FPS: --</div>
    </div>

    <h2>Demo 2: Interactive Grid (Table Foundation)</h2>
    <div class="section">
        <p>Click cells to highlight them. This is the GPU-rendered foundation for your data table!</p>
        <div class="grid-container">
            <canvas id="grid-canvas" width="700" height="400"></canvas>
            <div id="text-overlay" class="text-overlay"></div>
        </div>
        <div class="controls">
            <button onclick="initGridDemo(8, 5)">8Ã—5 Grid</button>
            <button onclick="initGridDemo(20, 8)">20Ã—8 Grid</button>
            <button onclick="initGridDemo(50, 10)">50Ã—10 Grid</button>
            <button onclick="initGridDemo(100, 15)">100Ã—15 Grid</button>
            <span style="margin-left: 1rem;"></span>
            <button id="btnUpdates" onclick="toggleUpdates()">â–¶ Start Updates</button>
        </div>
        <div class="stats" id="stats2">Click a cell to select it</div>
    </div>

    <h2>The Code Flow</h2>
    <div class="section">
        <h3>C Side (runs on GPU via WebGL):</h3>
        <pre>
// 1. Define vertices with position + color
float vertices[] = {
    // x,    y,    r,    g,    b
    -0.5f, -0.5f, 1.0f, 0.0f, 0.0f,  // red vertex
     0.5f, -0.5f, 0.0f, 1.0f, 0.0f,  // green vertex
     0.0f,  0.5f, 0.0f, 0.0f, 1.0f,  // blue vertex
};

// 2. Upload to GPU buffer
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

// 3. Draw!
glDrawArrays(GL_TRIANGLES, 0, 3);</pre>

        <h3>Vertex Shader (GLSL, runs per vertex):</h3>
        <pre>
attribute vec2 a_position;
attribute vec3 a_color;
varying vec3 v_color;  // Pass to fragment shader

void main() {
    v_color = a_color;
    gl_Position = vec4(a_position, 0.0, 1.0);
}</pre>

        <h3>Fragment Shader (GLSL, runs per pixel):</h3>
        <pre>
varying vec3 v_color;  // Interpolated from vertices!

void main() {
    gl_FragColor = vec4(v_color, 1.0);
}</pre>
    </div>

    <script>
        var Module = {
            onRuntimeInitialized: function() {
                document.getElementById('status').className = 'ready';
                document.getElementById('status').textContent = 'WebAssembly + WebGL ready!';
                initDemo1();
                initGridDemo(8, 5);
            }
        };

        // Demo 1: Animated quad
        let animating = false;
        let lastTime = 0;
        let frameCount = 0;
        let fpsTime = 0;

        function initDemo1() {
            const canvas = document.getElementById('webgl-canvas');
            Module._init_webgl(canvas.width, canvas.height);
            Module._render_frame(0);
        }

        function toggleAnimation() {
            animating = !animating;
            document.getElementById('btnAnimate').textContent = animating ? 'Stop' : 'Start Animation';
            document.getElementById('btnAnimate').className = animating ? 'active' : '';
            
            if (animating) {
                lastTime = performance.now();
                fpsTime = lastTime;
                frameCount = 0;
                requestAnimationFrame(animateDemo1);
            }
        }

        function animateDemo1(timestamp) {
            if (!animating) return;
            
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            frameCount++;
            if (timestamp - fpsTime >= 1000) {
                document.getElementById('stats1').textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                fpsTime = timestamp;
            }
            
            Module._render_frame(deltaTime);
            requestAnimationFrame(animateDemo1);
        }

        // Demo 2: Interactive grid with text overlay
        let gridRows = 0, gridCols = 0;
        let selectedRow = -1, selectedCol = -1;
        let cellData = {};  // Store edited values (these won't auto-update)
        let cellElements = [];  // DOM references for fast updates
        let priceData = {};  // Current prices for animation
        let updateInterval = null;
        let updating = false;
        let updateCount = 0;
        let lastUpdateTime = 0;

        function initGridDemo(rows, cols) {
            gridRows = rows;
            gridCols = cols;
            cellElements = [];
            priceData = {};
            
            const canvas = document.getElementById('grid-canvas');
            
            // Re-init WebGL context for grid canvas
            Module._init_webgl(canvas.width, canvas.height);
            Module._init_grid(rows, cols);
            Module._render_grid();
            
            // Create text overlay
            createTextOverlay(rows, cols, canvas.width, canvas.height);
            
            // Initialize price data for non-header rows
            for (let row = 1; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const key = `${row}-${col}`;
                    if (!cellData[key]) {  // Only if not manually edited
                        priceData[key] = 100 + Math.random() * 900;  // Random starting price
                    }
                }
            }
            
            document.getElementById('stats2').textContent = `${rows}Ã—${cols} grid â€” Click "Start Updates" to simulate live data`;
        }

        function createTextOverlay(rows, cols, canvasWidth, canvasHeight) {
            const overlay = document.getElementById('text-overlay');
            overlay.innerHTML = '';
            overlay.style.width = canvasWidth + 'px';
            overlay.style.height = canvasHeight + 'px';
            cellElements = [];
            
            const cellWidth = canvasWidth / cols;
            const cellHeight = canvasHeight / rows;
            const padding = 4;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const div = document.createElement('div');
                    div.className = 'cell-text';
                    div.style.left = (col * cellWidth + padding) + 'px';
                    div.style.top = (row * cellHeight + padding) + 'px';
                    div.style.width = (cellWidth - padding * 2) + 'px';
                    div.style.height = (cellHeight - padding * 2) + 'px';
                    div.style.lineHeight = (cellHeight - padding * 2) + 'px';
                    
                    const key = `${row}-${col}`;
                    let value = cellData[key];
                    if (value === undefined) {
                        if (row === 0) {
                            value = `Col ${col + 1}`;
                        } else {
                            value = priceData[key]?.toFixed(2) || (Math.random() * 1000).toFixed(2);
                        }
                    }
                    div.textContent = value;
                    div.dataset.row = row;
                    div.dataset.col = col;
                    
                    div.onclick = () => selectCell(row, col, div);
                    overlay.appendChild(div);
                    
                    // Store reference for fast updates
                    cellElements.push({ element: div, row, col, key });
                }
            }
        }

        function toggleUpdates() {
            updating = !updating;
            const btn = document.getElementById('btnUpdates');
            
            if (updating) {
                btn.textContent = 'â¹ Stop Updates';
                btn.className = 'active';
                updateCount = 0;
                lastUpdateTime = performance.now();
                updateInterval = setInterval(updatePrices, 333);  // 3x per second
            } else {
                btn.textContent = 'â–¶ Start Updates';
                btn.className = '';
                clearInterval(updateInterval);
            }
        }

        function updatePrices() {
            const startTime = performance.now();
            let cellsUpdated = 0;
            
            // Update all non-header, non-edited cells
            for (const cell of cellElements) {
                const { element, row, col, key } = cell;
                
                // Skip header row
                if (row === 0) continue;
                
                // Skip manually edited cells
                if (cellData[key] !== undefined) {
                    element.style.color = '#ffff00';  // Yellow for locked values
                    continue;
                }
                
                // Simulate stock price change (-2% to +2%)
                const oldPrice = priceData[key] || 500;
                const change = (Math.random() - 0.5) * 0.04 * oldPrice;
                const newPrice = Math.max(0.01, oldPrice + change);
                priceData[key] = newPrice;
                
                // Update display
                element.textContent = newPrice.toFixed(2);
                
                // Color based on change direction
                if (change > 0) {
                    element.style.color = '#00ff88';  // Green for up
                } else {
                    element.style.color = '#ff6b6b';  // Red for down
                }
                
                cellsUpdated++;
            }
            
            // Stats
            updateCount++;
            const elapsed = performance.now() - startTime;
            const totalTime = performance.now() - lastUpdateTime;
            const updatesPerSec = (updateCount / (totalTime / 1000)).toFixed(1);
            
            document.getElementById('stats2').textContent = 
                `Updated ${cellsUpdated} cells in ${elapsed.toFixed(1)}ms | ${updatesPerSec} updates/sec | Edited cells stay fixed (yellow)`;
        }

        function selectCell(row, col, element) {
            // Reset previous selection
            if (selectedRow >= 0) {
                const prevRow = selectedRow;
                const prevCol = selectedCol;
                // Reset to original color
                if (prevRow === 0) {
                    Module._set_cell_color(prevRow, prevCol, gridCols, 0.0, 0.5, 0.7);
                } else if (prevRow % 2 === 0) {
                    Module._set_cell_color(prevRow, prevCol, gridCols, 0.15, 0.15, 0.25);
                } else {
                    Module._set_cell_color(prevRow, prevCol, gridCols, 0.2, 0.2, 0.32);
                }
            }
            
            // Highlight new selection
            selectedRow = row;
            selectedCol = col;
            Module._set_cell_color(row, col, gridCols, 0.0, 1.0, 0.5);  // Green highlight
            Module._update_grid_buffer();
            Module._render_grid();
            
            // Make cell editable
            element.contentEditable = true;
            element.classList.add('editing');
            element.focus();
            
            // Select all text
            const range = document.createRange();
            range.selectNodeContents(element);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            
            element.onblur = () => {
                element.contentEditable = false;
                element.classList.remove('editing');
                // Store the edited value - this locks it from auto-updates
                const key = `${row}-${col}`;
                cellData[key] = element.textContent;
                element.classList.add('locked');
            };
            
            element.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    element.blur();
                }
            };
            
            document.getElementById('stats2').textContent = `Selected: Row ${row}, Col ${col} â€” Edit the value!`;
        }
    </script>
    <script src="build/webgl.js"></script>
</body>
</html>
